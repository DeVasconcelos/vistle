#include <Python.h>
#include <boost/python.hpp>
#include <boost/python/suite/indexing/vector_indexing_suite.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/uuid/string_generator.hpp>

#include <core/message.h>
#include <core/parameter.h>
#include <core/port.h>

#include "pythonmodule.h"
#include "pythonembed.h"
#include "vistleconnection.h"

//#define DEBUG

#include <core/statetracker.h>
#include <core/porttracker.h>

#define moduleManager ((PythonModule::the().vistleConnection().ui().state()))

#define LOCKED() vistle::VistleConnection::mutex_lock(PythonModule::the().vistleConnection().m_mutex)

namespace bp = boost::python;

BOOST_PYTHON_MODULE(vector_indexing_suite_ext){
   bp::class_<std::vector<int> >("PyVec")
      .def(bp::vector_indexing_suite<std::vector<int> >());
}

namespace vistle {

PythonModule *PythonModule::s_instance = nullptr;

static void sendMessage(const vistle::message::Message &m) {

   PythonModule::the().vistleConnection().sendMessage(m);
}

static void resetModuleCounter() {

   sendMessage(message::ResetModuleIds());
}

static void source(const std::string &filename) {

   PythonInterface::the().exec_file(filename);
}

static void quit() {

#ifdef DEBUG
   std::cerr << "Python: quit" << std::endl;
#endif
   message::Quit m;
   sendMessage(m);
}

static void ping(char c) {

#ifdef DEBUG
   std::cerr << "Python: ping: " << c << std::endl;
#endif
   message::Ping m(c);
   sendMessage(m);
}

static int barrier() {

   return PythonModule::the().vistleConnection().barrier();
}

static std::string spawnAsync(const char *module, int numSpwan=-1, int baseRank=-1, int rankSkip=-1) {

#ifdef DEBUG
   std::cerr << "Python: spawnAsync "<< module << std::endl;
#endif
   int id = 0; // will be generated by module manager
   message::Spawn m(id, module, numSpwan, baseRank, rankSkip);

   if (!PythonModule::the().vistleConnection().requestReplyAsync(m)) {
      return std::string();
   }

   return boost::lexical_cast<std::string>(m.uuid());
}
BOOST_PYTHON_FUNCTION_OVERLOADS(spawnAsync_overloads, spawnAsync, 1, 4)

static int waitForSpawn(const std::string &uuid) {

   std::vector<char> msgBuf(message::Message::MESSAGE_SIZE);
   message::Message *msg = (message::Message *)msgBuf.data();
   boost::uuids::string_generator gen;
   message::Message::uuid_t u = gen(uuid);
   if (!PythonModule::the().vistleConnection().waitForReplyAsync(u, *msg)) {
      return -1;
   }

   switch(msg->type()) {
      case message::Message::SPAWN: {
         const message::Spawn *spawn = static_cast<const message::Spawn *>(msg);
         return spawn->spawnId();
         break;
      }
      default:
         assert("expected Spawn message" == 0);
         break;
   }

   return -1;
}

static int spawn(const char *module, int numSpwan=-1, int baseRank=-1, int rankSkip=-1) {

#ifdef DEBUG
   std::cerr << "Python: spawn "<< module << std::endl;
#endif
   const std::string uuid = spawnAsync(module, numSpwan, baseRank, rankSkip);
   return waitForSpawn(uuid);
}
BOOST_PYTHON_FUNCTION_OVERLOADS(spawn_overloads, spawn, 1, 4)

static void kill(int id) {

#ifdef DEBUG
   std::cerr << "Python: kill "<< id << std::endl;
#endif
   message::Kill m(id);
   sendMessage(m);
}

static std::vector<int> getRunning() {

   LOCKED();
#ifdef DEBUG
   std::cerr << "Python: getRunning " << std::endl;
#endif
   return moduleManager.getRunningList();
}

static std::vector<int> getBusy() {

   LOCKED();
#ifdef DEBUG
   std::cerr << "Python: getBusy " << std::endl;
#endif
   return moduleManager.getBusyList();
}

static std::vector<std::string> getInputPorts(int id) {

   LOCKED();
   return moduleManager.portTracker()->getInputPortNames(id);
}

static std::vector<std::string> getOutputPorts(int id) {

   LOCKED();
   return moduleManager.portTracker()->getOutputPortNames(id);
}

static std::vector<std::pair<int, std::string> > getConnections(int id, const std::string &port) {

   LOCKED();
   std::vector<std::pair<int, std::string> > result;

   if (const Port::PortSet *c = moduleManager.portTracker()->getConnectionList(id, port)) {
      for (const Port *p: *c) {
         result.push_back(std::pair<int, std::string>(p->getModuleID(), p->getName()));
      }
   }

   return result;
}

static std::vector<std::string> getParameters(int id) {

   LOCKED();
   return moduleManager.getParameters(id);
}

static std::string getParameterType(int id, const std::string &name) {

   LOCKED();
   const Parameter *param = moduleManager.getParameter(id, name);
   if (!param) {
      std::cerr << "Python: getParameterType: no such parameter" << std::endl;
      return "None";
   }

   switch (param->type()) {
      case Parameter::Integer: return "Int";
      case Parameter::Float: return "Float";
      case Parameter::Vector: return "Vector";
      case Parameter::String: return "String";
      case Parameter::Invalid: return "None";
      case Parameter::Unknown: return "None";
   }

   return "None";
}

static bool isParameterDefault(int id, const std::string &name) {

   LOCKED();
   const Parameter *param = moduleManager.getParameter(id, name);
   if (!param) {
      std::cerr << "Python: getParameterType: no such parameter" << std::endl;
      return false;
   }

   return param->isDefault();
}

template<typename T>
static T getParameterValue(int id, const std::string &name) {

   LOCKED();
   const Parameter *param = moduleManager.getParameter(id, name);
   if (!param) {
      std::cerr << "Python: getParameterValue: no such parameter" << std::endl;
      return T();
   }

   const ParameterBase<T> *tparam = dynamic_cast<const ParameterBase<T> *>(param);
   if (!tparam) {
      std::cerr << "Python: getParameterValue: type mismatch" << std::endl;
      return T();
   }

   return tparam->getValue();
}

static std::string getModuleName(int id) {

   LOCKED();
#ifdef DEBUG
   std::cerr << "Python: getModuleName(" id << ")" << std::endl;
#endif
   return moduleManager.getModuleName(id);
}

static void connect(int sid, const char *sport, int did, const char *dport) {

#ifdef DEBUG
   std::cerr << "Python: connect "<< sid << ":" << sport << " -> " << did << ":" << dport << std::endl;
#endif
   message::Connect m(sid, sport, did, dport);
   sendMessage(m);
}

static void disconnect(int sid, const char *sport, int did, const char *dport) {

#ifdef DEBUG
   std::cerr << "Python: disconnect "<< sid << ":" << sport << " -> " << did << ":" << dport << std::endl;
#endif
   message::Disconnect m(sid, sport, did, dport);
   sendMessage(m);
}

static void setIntParam(int id, const char *name, Integer value) {

#ifdef DEBUG
   std::cerr << "Python: setIntParam " << id << ":" << name << " = " << value << std::endl;
#endif
   message::SetParameter m(id, name, value);
   sendMessage(m);
}

static void setFloatParam(int id, const char *name, Float value) {

#ifdef DEBUG
   std::cerr << "Python: setFloatParam " << id << ":" << name << " = " << value << std::endl;
#endif
   message::SetParameter m(id, name, value);
   sendMessage(m);
}

static void setVectorParam4(int id, const char *name, Float v1, Float v2, Float v3, Float v4) {

   message::SetParameter m(id, name, ParamVector(v1, v2, v3, v4));
   sendMessage(m);
}

static void setVectorParam3(int id, const char *name, Float v1, Float v2, Float v3) {

   message::SetParameter m(id, name, ParamVector(v1, v2, v3));
   sendMessage(m);
}

static void setVectorParam2(int id, const char *name, Float v1, Float v2) {

   message::SetParameter m(id, name, ParamVector(v1, v2));
   sendMessage(m);
}

static void setVectorParam1(int id, const char *name, Float v1) {

   message::SetParameter m(id, name, ParamVector(v1));
   sendMessage(m);
}

static void setStringParam(int id, const char *name, const std::string &value) {

#ifdef DEBUG
   std::cerr << "Python: setStringParam " << id << ":" << name << " = " << value << std::endl;
#endif
   message::SetParameter m(id, name, value);
   sendMessage(m);
}

static void compute(int id) {

#ifdef DEBUG
   std::cerr << "Python: compute " << id << std::endl;
#endif
   message::Compute m(id, -1);
   sendMessage(m);
}

#define param(T, f) \
   def("set" #T "Param", f, "set parameter `arg2` of module with ID `arg1` to `arg3`"); \
   def("setParam", f, "set parameter `arg2` of module with ID `arg1` to `arg3`");

BOOST_PYTHON_MODULE(_vistle)
{
    using namespace boost::python;

    def("_resetModuleCounter", resetModuleCounter);

    def("source", source, "execute commands from file `arg1`");
    def("spawn", spawn, spawn_overloads(args("modulename", "numspawn", "baserank", "rankskip"), "spawn new module `arg1`\n" "return its ID"));
    def("spawnAsync", spawnAsync, spawnAsync_overloads(args("modulename", "numspawn", "baserank", "rankskip"), "spawn new module `arg1`\n" "return uuid to wait on its ID"));
    def("waitForSpawn", waitForSpawn, "wait for asynchronously spawned module with uuid `arg1` and return its ID");
    def("kill", kill, "kill module with ID `arg1`");
    def("connect", connect, "connect output `arg2` of module with ID `arg1` to input `arg4` of module with ID `arg3`");
    def("disconnect", disconnect, "disconnect output `arg2` of module with ID `arg1` to input `arg4` of module with ID `arg3`");
    def("compute", compute, "trigger execution of module with ID `arg1`");
    def("quit", quit, "quit vistle session");
    def("ping", ping, "send first character of `arg1` to every vistle process");
    def("barrier", barrier, "wait until all modules reply");
    //def("checkMessageQueue", checkMessageQueue, "check whether all messages have been processed");

    param(Int, setIntParam);
    param(Float, setFloatParam);
    param(String, setStringParam);
    param(Vector, setVectorParam1);
    param(Vector, setVectorParam2);
    param(Vector, setVectorParam3);
    param(Vector, setVectorParam4);

    def("getRunning", getRunning, "get list of IDs of running modules");
    def("getBusy", getBusy, "get list of IDs of busy modules");
    def("getModuleName", getModuleName, "get name of module with ID `arg1`");
    def("getInputPorts", getInputPorts, "get name of input ports of module with ID `arg1`");
    def("getOutputPorts", getOutputPorts, "get name of input ports of module with ID `arg1`");
    def("getConnections", getConnections, "get connections to/from port `arg2` of module with ID `arg1`");
    def("getParameters", getParameters, "get list of parameters for module with ID `arg1`");
    def("getParameterType", getParameterType, "get type of parameter named `arg2` of module with ID `arg1`");
    def("isParameterDefault", isParameterDefault, "check whether parameter `arg2` of module with ID `arg1` differs from its default value");
    def("getIntParam", getParameterValue<Integer>, "get value of parameter named `arg2` of module with ID `arg1`");
    def("getFloatParam", getParameterValue<Float>, "get value of parameter named `arg2` of module with ID `arg1`");
    def("getVectorParam", getParameterValue<ParamVector>, "get value of parameter named `arg2` of module with ID `arg1`");
    def("getStringParam", getParameterValue<std::string>, "get value of parameter named `arg2` of module with ID `arg1`");
}

PythonModule::PythonModule(VistleConnection *vc)
   : m_vistleConnection(vc)
{
   assert(s_instance == nullptr);
   s_instance = this;

   import(&PythonInterface::the().nameSpace());
}

PythonModule &PythonModule::the()
{
   assert(s_instance);
   return *s_instance;
}

VistleConnection &PythonModule::vistleConnection() const
{
   assert(m_vistleConnection);
   return *m_vistleConnection;
}

bool PythonModule::import(boost::python::object *ns) {

   bp::class_<std::vector<int> >("vector<int>")
      .def(bp::vector_indexing_suite<std::vector<int> >());

   bp::class_<std::vector<std::string> >("vector<string>")
      .def(bp::vector_indexing_suite<std::vector<std::string> >());

   bp::class_<std::vector<std::pair<int, std::string> > >("vector<pair<int,string>>")
      .def(bp::vector_indexing_suite<std::vector<std::pair<int, std::string> > >());

   bp::class_<std::pair<int, std::string> >("pair<int,string>")
      .def_readwrite( "first", &std::pair< int, std::string >::first, "first value" )
      .def_readwrite( "second", &std::pair< int, std::string >::second, "second value" );

   bp::class_<ParameterVector<Float> >("ParameterVector<Float>")
      .def(bp::vector_indexing_suite<ParameterVector<Float> >());

   try {
      init_vistle();
   } catch (bp::error_already_set) {
      std::cerr << "vistle Python module initialisation failed" << std::endl;
      PyErr_Print();
      return false;
   }

   try {
      (*ns)["_vistle"] = bp::import("_vistle");
   } catch (bp::error_already_set) {
      std::cerr << "vistle Python module import failed" << std::endl;
      PyErr_Print();
      return false;
   }

   if (!PythonInterface::the().exec("import vistle"))
      return false;
   if (!PythonInterface::the().exec("from vistle import *"))
      return false;

   return true;
}

} // namespace vistle
